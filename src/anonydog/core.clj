(ns anonydog.core
  (:require [clojure.edn :as edn]
            [clojure.core.async :refer [chan close!]]
            [discljord.messaging :as discord-rest]
            [discljord.connections :as discord-ws]
            [discljord.formatting :refer [mention-user]]
            [discljord.events :refer [message-pump!]]))

(def state (atom nil))

(def help-string (str
  "**Welcome to the /r/UMBC Discord's Anonymous Messaging Bot.** \n\n"
  "Anything that you DM me (except for `!help`) will be sent to "
  "the #therapy_room channel on the UMBC discord. \n\n"
  "Your username will be replaced with an anonymous code. "
  "This anonymous code is unique to you and will appear every time you "
  "send a message. However, your anonymous code cannot be traced back to your actual user account. \n\n"
  "*Implementation details:* Anonymous codes are generated by concatenating your Discord user ID "
  "with a secret key value, then hashing the result, and `mod`ing by 9999. "
  "In addition to the 4-digit code, for human-readability, you are also assigned a two-word "
  "pseudorandom \"fake name\", generated from the anonymous code."
  ))

(def bot-id (atom nil))

(def config (edn/read-string (slurp "config.edn")))
(def wordlist-file (edn/read-string (slurp "wordlist.edn")))
(def wordlist (:wordlist wordlist-file))
(def wordlist-length (count wordlist))

(defmulti handle-event (fn [type _data] type))

; (defn random-response [user]
;   (str (rand-nth (:responses config)) ", " (mention-user user) \!))

(defn process-dm [user-id dm-channel mess-content]
  (if (clojure.string/starts-with? mess-content "!help")
    (discord-rest/create-message! (:rest @state) dm-channel :content help-string)
    (do
      (discord-rest/create-message! (:rest @state) dm-channel :content "Sending...")
      (def anon-hash (Math/abs (hash
        (str user-id (:anon-nonce config))
        )))
      (def anon-hash-short (mod anon-hash 9999))
      (def anon-word-1 (clojure.string/capitalize (get
        wordlist
        (mod (hash (+ anon-hash 1)) wordlist-length))))
      (def anon-word-2 (clojure.string/capitalize (get
        wordlist
        (mod (hash (+ anon-hash 2)) wordlist-length))))
      (discord-rest/create-message! (:rest @state) (:anon-channel-id config) :content
        (str
          "**Anon #"
          anon-hash-short
          " ("
          anon-word-1
          anon-word-2
          "):** "
          mess-content
        )
      )
      (discord-rest/create-message! (:rest @state) dm-channel :content "Sent.")
    )
  ))

(defmethod handle-event :message-create
  [_ {:keys [channel-id content author] :as mess-data}]
  ; (when (some #{@bot-id} (map :id mentions))
  ;   (discord-rest/create-message! (:rest @state) channel-id :content (random-response author))))
  ; (clojure.pprint/pprint @bot-id)
  ; (clojure.pprint/pprint (get author :id))
  (when
    (and
      (not (contains? mess-data :guild-id))
      (not= (get author :id) @bot-id))
    (process-dm (get author :id) channel-id content)
    ))

(defmethod handle-event :ready
  [_ _]
  (discord-ws/status-update! (:gateway @state) :activity (discord-ws/create-activity :name (:playing config))))

(defmethod handle-event :default [_ _])

(defn start-bot! [token & intents]
  (let [event-channel (chan 100)
        gateway-connection (discord-ws/connect-bot! token event-channel :intents (set intents))
        rest-connection (discord-rest/start-connection! token)]
    {:events  event-channel
     :gateway gateway-connection
     :rest    rest-connection}))

(defn stop-bot! [{:keys [rest gateway events] :as _state}]
  (discord-rest/stop-connection! rest)
  (discord-ws/disconnect-bot! gateway)
  (close! events))

(defn -main [& args]
  (reset! state (start-bot! (:token config) :guild-messages :direct-messages))
  (reset! bot-id (:id @(discord-rest/get-current-user! (:rest @state))))
  (try
    (message-pump! (:events @state) handle-event)
    (finally (stop-bot! @state))))

