(ns anonydog.core
  (:require [clojure.edn :as edn]
            [clojure.core.async :refer [chan close!]]
            [discljord.messaging :as discord-rest]
            [discljord.connections :as discord-ws]
            [discljord.formatting :refer [mention-user]]
            [discljord.events :refer [message-pump!]]))

(def state (atom nil))

(defn newid-info [passcode how-many-uses]
  (str
    "The !newid command will allow you to force a new anonymous ID.\n"
    "**WARNING**: There is no way for you, the user, to revert back to your old ID. This is intentional, "
    "since the bot operator should totally 'refresh' the IDs every couple of weeks anyways - don't get too "
    "attached to your anonymous ID.\n"
    "Note: The newid system is not particularly robust. Though it is very unlikely, file corruption or "
    "human error on the bot server may result in you accidentally re-gaining your *original* anonymous ID. Please do not "
    "rely too much on newid secrecy.\n"
    "Note: You have acquired " how-many-uses " new IDs so far.\n"
    "Anyways, to confirm you wish to get a new ID, type\n"
    "```\n"
    "!newid " passcode
    "```\n"
  ))

(def bot-id (atom nil))

(def config (edn/read-string (slurp "config.edn")))
(def wordlist-file (edn/read-string (slurp "wordlist.edn")))
(def wordlist (:wordlist wordlist-file))
(def wordlist-length (count wordlist))

(def help-string (str
  "**Welcome to the " (:server-name config) "'s Anonymous Messaging Bot.** \n\n"
  "Anything that you DM me (except for `!` commands) will be sent to "
  "the " (:anon-channel-name config) " channel on the " (:server-name config) ". \n\n"
  "Your username will be replaced with an anonymous code. "
  "This anonymous code is unique to you and will appear every time you "
  "send a message. However, your anonymous code cannot be traced back to your actual user account. \n\n"
  "*Implementation details:* Anonymous codes are generated by concatenating your Discord user ID "
  "with a secret key value, then hashing the result, and `mod`ing by 9999. "
  "In addition to the 4-digit code, for human-readability, you are also assigned a two-word "
  "pseudorandom \"fake name\", generated from the anonymous code. Source code for this bot is "
  "available on Github; just ask and we will provide the link.\n\n"
  "Other commands:\n"
  "`!myid` Preview your current anonymous ID.\n"
  "`!newid` Force generation of a new anonymous ID.\n"
  ))

; INITIALIZE HASHES LIST
(def hashes-list-filename "hasheslist.edn")
(def hashes-list
  (if (.exists (clojure.java.io/file hashes-list-filename))
    (edn/read-string (slurp hashes-list-filename))
    {}
  ))

(defmulti handle-event (fn [type _data] type))

; HASHING / ANONYMOUS IDS FUNCTIONS
(defn discord-id-to-hash-original [discord-id]
  (Math/abs (hash
    (str discord-id (:anon-nonce config))
  )))
(defn discord-id-to-hash [discord-id]
  (def original-hash (discord-id-to-hash-original discord-id))
  (def newid-requests (get hashes-list original-hash 0))
  (if (= newid-requests 0)
    original-hash
    (Math/abs (hash
      (str original-hash newid-requests)
    ))
  )
)
(defn hash-to-fullname [anon-hash]
  (def anon-hash-short (mod anon-hash 9999))
  (def anon-word-1 (clojure.string/capitalize (get
    wordlist
    (mod (hash (+ anon-hash 1)) wordlist-length))))
  (def anon-word-2 (clojure.string/capitalize (get
    wordlist
    (mod (hash (+ anon-hash 2)) wordlist-length))))
  (str
    "Anon #"
    anon-hash-short
    " ("
    anon-word-1
    anon-word-2
    ")"
  )
)

; PROCESS MESSAGE WHICH IS NOT A COMMAND (Send message anonymously to target channel)
(defn process-noncommand [user-id dm-channel mess-content]
  (do
    (discord-rest/create-message! (:rest @state) dm-channel :content "Sending...")
    (def anon-hash (discord-id-to-hash user-id))
    (def fullname (hash-to-fullname anon-hash))
    (discord-rest/create-message! (:rest @state) (:anon-channel-id config) :content
      (str
        "**"fullname":** "
        mess-content
      )
    )
    (discord-rest/create-message! (:rest @state) dm-channel :content "Sent.")
  )
)

; NEWID COMMAND
(def newid-maximum-uses 500)
(defn newid-passcode []
  (+ (mod (hash (.getHour (java.time.LocalDateTime/now))) 80) 10))
(defn send-newid-help [dm-channel how-many-uses]
  (discord-rest/create-message! (:rest @state) dm-channel :content (newid-info (newid-passcode) how-many-uses)))

(defn execute-id-change [user-id dm-channel]
  (def original-hash (discord-id-to-hash-original user-id))
  (def fullname-before (hash-to-fullname (discord-id-to-hash user-id)))
  (discord-rest/create-message! (:rest @state) dm-channel :content
    (str "Current ID is `" fullname-before "`. Changing ID..."))
  ; increment entry in hashes-list
  (def new-hashes-list (assoc hashes-list original-hash
    (+ (get hashes-list original-hash 0) 1)))
  ; write to file
  (spit hashes-list-filename (prn-str new-hashes-list))
  ; re-read hashes list, just to be sure
  ; TODO: concurrency is going to be a problem here
  (def hashes-list
    (if (.exists (clojure.java.io/file hashes-list-filename))
      (edn/read-string (slurp hashes-list-filename))
      {}
    ))
  ; print out success message
  (def fullname-after (hash-to-fullname (discord-id-to-hash user-id)))
  (def how-many-uses (get hashes-list original-hash 0))
  (discord-rest/create-message! (:rest @state) dm-channel :content
    (str "This is your " (clojure.pprint/cl-format nil "~:R" how-many-uses)
      " ID change. You are now: **" fullname-after "**"))
  (if (> how-many-uses (- newid-maximum-uses 50))
    (discord-rest/create-message! (:rest @state) dm-channel :content
      (str "Warning: Approaching newid usage limit. You are limited to "
        newid-maximum-uses " uses of the !newid command. You have used "
        how-many-uses " so far."))
  )
)

(defn newid-command [user-id dm-channel mess-content]
  (def arg (nth (clojure.string/split mess-content #" ") 1 0))
  (def how-many-uses (get hashes-list (discord-id-to-hash-original user-id) 0))
  (if (= arg 0)
    (send-newid-help dm-channel how-many-uses)
    (try
      (if (= (Integer/parseInt arg) (newid-passcode))
        (if (> how-many-uses newid-maximum-uses)
          (discord-rest/create-message! (:rest @state) dm-channel :content
            (str "Error: You are blocked from !newid. Users are limited to "
              newid-maximum-uses " uses of the !newid command. Contact an admin."))
          (execute-id-change user-id dm-channel)
        )
        (send-newid-help dm-channel how-many-uses)
      )
      (catch Exception e
        (send-newid-help dm-channel how-many-uses)))
  )
)

; MYID COMMAND
(defn myid-command [user-id dm-channel mess-content]
  (def fullname (hash-to-fullname (discord-id-to-hash user-id)))
  (discord-rest/create-message! (:rest @state) dm-channel :content
    (str "You are: **" fullname "**"))
)

; PROCESS MESSAGE WHICH IS A COMMAND (Starts with "!")
(defn process-command [user-id dm-channel mess-content]
  (defn bot-cmd-is [cmd-string] (clojure.string/starts-with? mess-content cmd-string))
  (cond
    (or (bot-cmd-is "!help") (bot-cmd-is "!?"))
      (discord-rest/create-message! (:rest @state) dm-channel :content help-string)
    (or (bot-cmd-is "!myid") (bot-cmd-is "!whoami"))
      (myid-command user-id dm-channel mess-content)
    (bot-cmd-is "!newid")
      (newid-command user-id dm-channel mess-content)
    :else
      (discord-rest/create-message! (:rest @state) dm-channel :content "Unrecognized command.")
  )
)

; PROCESS INCOMING PRIVATE MESSAGE
(defn process-dm [user-id dm-channel mess-content]
  (if (clojure.string/starts-with? mess-content "!")
    (process-command    user-id dm-channel mess-content)
    (process-noncommand user-id dm-channel mess-content)
  )
)

; HANDLE INCOMING MESSAGE EVENT
(defmethod handle-event :message-create
  [_ {:keys [channel-id content author] :as mess-data}]
  (when
    (and
      (not (contains? mess-data :guild-id))
      (not= (get author :id) @bot-id))
    (process-dm (get author :id) channel-id content)
    ))

(defmethod handle-event :ready
  [_ _]
  (discord-ws/status-update! (:gateway @state) :activity (discord-ws/create-activity :name (:playing config))))

(defmethod handle-event :default [_ _])

(defn start-bot! [token & intents]
  (let [event-channel (chan 100)
        gateway-connection (discord-ws/connect-bot! token event-channel :intents (set intents))
        rest-connection (discord-rest/start-connection! token)]
    {:events  event-channel
     :gateway gateway-connection
     :rest    rest-connection}))

(defn stop-bot! [{:keys [rest gateway events] :as _state}]
  (discord-rest/stop-connection! rest)
  (discord-ws/disconnect-bot! gateway)
  (close! events))

(defn -main [& args]
  (reset! state (start-bot! (:token config) :guild-messages :direct-messages))
  (reset! bot-id (:id @(discord-rest/get-current-user! (:rest @state))))
  (try
    (message-pump! (:events @state) handle-event)
    (finally (stop-bot! @state))))

